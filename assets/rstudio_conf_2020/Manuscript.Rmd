---
title             : "Working with list-columns in `data.table`"
shorttitle        : "List-columns in data.table"
author: 
  - name          : "Tyson S. Barrett"
    affiliation   : "1"
    corresponding : yes    # Define only one corresponding author
    address       : "2800 Old Main, Logan, UT 84322"
    email         : "tyson.barrett@usu.edu"
affiliation:
  - id            : "1"
    institution   : "Utah State University"
abstract: |
  The use of *list-columns* in data frames and tibbles is well documented [e.g. @jenny], providing a cognitively efficient way to organize results of complex data (e.g. several statistical models, groupings of text, data summaries, or even graphics) with corresponding data. For example, we can store text of a verse in a list for each verse, chapter, book, and volume. This allows the text to be of variable sizes without overly complicating or adding redundancies to the structure of the data.  In turn, this can reduce the difficulty to appropriately analyze the data stored in the list-column. Because of its efficiency and speed, being able to use `data.table` to work with list-columns would be beneficial in many data contexts (i.e. to reduce memory usage in large data sets). I show how one can create list-columns in a data table using `purrr::map()` and the `by` argument in `data.table`. I further show the `dplyr::group_nest()` function and show a more efficient approach when using a data table. Results using `bench::mark()` show the speed and efficiency of using `data.table` to work with list-columns. An example walk-through is provided in the appendix herein. 
keywords          : "data.table, dplyr, list-columns, nesting"
bibliography      : ["r-references.bib"]
floatsintext      : no
figurelist        : no
tablelist         : no
footnotelist      : no
linenumbers       : no
mask              : no
draft             : no
documentclass     : "apa6"
classoption       : "doc"
output            : 
  papaja::apa6_pdf:
    highlight: tango
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
library(papaja)
library(data.table)
library(dplyr)
library(stringr)
library(rvest)
library(bench)
library(ggbeeswarm)
library(janitor)
library(performance)
```


```{r analysis-preferences}
# Seed for random number generation
set.seed(42)
knitr::opts_chunk$set(cache.extra = knitr::rand_seed,
                      echo = TRUE)
```

# Introduction

The use of *list-columns* in data frames and tibbles provides a cognitively efficient way to organize results of complex data (e.g. several statistical models, groupings of text, data summaries, or even graphics) with corresponding data. It is often called "nested" data, where information is, in essence, nested within a column of data. For example, we can store text of a verse in a list for each verse, chapter, book, and volume. This allows the text to be of variable sizes without overly complicating or adding redundancies to the structure of the data. We could also nest students within classrooms, players within teams, and measures within individuals. 

In turn, nesting can reduce the difficulty to appropriately analyze the data stored in the list-column. Using functions like `lapply()` or `purrr::map*()` makes further analysis of the nested data more intuitive.

Because of its efficiency and speed, being able to use `data.table` to work with list-columns would be beneficial in many data contexts (i.e. to reduce memory usage in large data sets). Herein, I show how one can create list-columns in a data table using `purrr::map()` and the `by` argument in `data.table`. I further highlight the `dplyr::group_nest()` function and show a more efficient approach when using a data table. Results using `bench::mark()` show the speed and efficiency of using `data.table` to work with list-columns. 

This tutorial relies on several powerful packages, including `data.table`, `dplyr`, `bench`, `tidyr`, `papaja`, `stringr`, `ggplot2`, `ggbeeswarm`, `performance`, and `rvest` [@R-data.table; @R-dplyr; @R-bench; @R-tidyr; @R-papaja; @R-stringr; @R-ggbeeswarm; @R-ggplot2; @R-rvest; @R-performance].

# Example with NBA Data
## The Data

To demonstrate the use of *list-columns* in `data.table`, data from [NBA Stuffer](nbastuffer.com) will be scraped to get information on players from the 2017-2018 and 2018-2019 seasons. First, the HTML data are read in, the tables with player data by year are then extracted using a custom function, indicators are added, and then combined into a single data table for the player data.

```{r, warning = FALSE}
url_2018 <- "https://www.nbastuffer.com/2017-2018-nba-player-stats/"
url_2019 <- "https://www.nbastuffer.com/2018-2019-nba-player-stats/"
players_2018 <- read_html(url_2018)
players_2019 <- read_html(url_2019)

extract_fun <- function(html){
  html_nodes(html, "table") %>% 
    .[2] %>% 
    html_table(fill = TRUE) %>% 
    .[[1]] 
}

player_2018 <- 
  extract_fun(players_2018) %>% 
  mutate(year = 2018,
         AGE = as.numeric(AGE))
player_2019 <- 
  extract_fun(players_2019) %>% 
  mutate(year = 2019)
players <- 
  bind_rows(player_2018, player_2019) %>% 
  clean_names() %>% 
  rename(ppg = ppg_points_points_per_game,
         apg = apg_assists_assists_per_game) %>% 
  data.table()
```

Below is a subset of this data set.

```{r, echo = FALSE}
head(players[, .(full_name, mpg, ppg, apg)])
```

## Nesting Players within Teams

In `dplyr` the `group_nest()` function is valuable when creating list-columns based on a grouping variable. It takes the data by group and puts it all in a list-column. Figure \ref{process} highlights the process of taking a data frame and creating a nested data frame with a list-column. That is, all data from variables `x`, `y`, and `z` relating to each group is split into a distinct data frame and stored within the `data` column.

\begin{figure}[htb]
  \centering
  \includegraphics[width=\textwidth]{fig_process.png}
  \caption{Speed comparisons for each nesting approach.}
  \label{process}
\end{figure}

Overall, this function is efficient and fast but by using `data.table` it can be faster. This will be shown using the following function:

```{r}
group_nest_dt <- function(dt, ..., .key = "data"){
  stopifnot(is.data.table(dt))

  by <- substitute(list(...))
  
  express <- dt[, list(list(.SD)), by = eval(by)]
  setnames(express, old = "V1", new = .key)
  express
}
```

In essence, this function takes a data table, then creates a list of the data table per group specified in the `by` argument.
```{r}
group_nest_dt(players, team) %>% 
  head()
```

This is nearly identical to the `dplyr::group_nest()` function, in terms of output, but has data tables in the list-column instead of tibbles.
```{r}
group_nest(players, team) %>% 
  head()
```

```{r, echo=FALSE}
players_tbl <- as_tibble(players)
first = bench::mark(group_nest = group_nest(players_tbl, team))
second = bench::mark(group_nest_dt = group_nest_dt(players,by = team))
```

Importantly, Figure \ref{speed} presents the timings from `bench::mark()` across the two approaches, showing `group_nest_dt()` is somewhat faster. The memory allocated is very similar, with `group_nest_dt()` allocating `r second$mem_alloc` and `group_nest()` allocating `r first$mem_alloc`.

```{r, echo=FALSE}
theme_set(theme_minimal() +
          theme(panel.grid.major.x = element_blank(),
                legend.position = "none"))
p <- rbind(first, second) %>% 
  tidyr::unnest(time) %>% 
  select(expression, time) %>% 
  ggplot(aes(x = expression, 
             y = time, 
             color = expression, 
             fill = expression)) +
    geom_beeswarm(size = 1.5, alpha = .8) +
    labs(y = expression(paste("Milliseconds (", log[10], " Scale)")),
         x = "") +
    scale_color_viridis_d(end = 1, begin = .2)
ggsave(here::here("assets/rstudio_conf_2020/timings_manuscript.png"), plot = p,
       height = 4, width = 4)
```

\begin{figure}[htb]
  \centering
  \includegraphics[width=0.6\textwidth]{timings_manuscript.png}
  \caption{Speed comparisons for each nesting approach.}
  \label{speed}
\end{figure}

This nesting approach can be used with multiple grouping variables too. For example, we can nest by both `team` and `year`, as is done below.

```{r}
group_nest_dt(players, team, year) %>% 
  head()
```

## Modeling within the Nest

Often, the nested data can provide an intuitive format to run several models to understand key features of the data within the groups. Below, the relationship between points-per-game and assists-per-game for each team and year is modeled and then the $R^2$ of the models are extracted.

```{r}
players_nested <- group_nest_dt(players, team, year) %>% 
  .[, ppg_apg    := purrr::map(data, ~lm(ppg ~ apg, data = .x))] %>% 
  .[, r2_list    := purrr::map(ppg_apg, ~performance::r2(.x))] %>% 
  .[, r2_ppg_apg := purrr::map_dbl(r2_list, ~.x[[1]])]
head(players_nested)
```

\noindent This produces two list-columns (`ppg_apg` and `r2_list`) and a numeric vector (`r2_ppg_apg`) all organized by team and year. This information is then readily available to plot. For example, we can look at the change in how related points-per-game and assists-per-game are by team and year.

```{r}
library(ggrepel)
theme_set(theme_minimal() +
          theme(panel.grid.major.x = element_blank(),
                legend.position = "none"))

ex_fig <- players_nested %>% 
  dcast(team ~ year, value.var = "r2_ppg_apg") %>% 
  ggplot(aes(`2018`, `2019`, group = team)) +
    geom_point() +
    geom_text_repel(aes(label = team)) +
    geom_abline(slope = 1) +
    coord_fixed(ylim = c(0,1),
                xlim = c(0,1))
```

```{r, echo = FALSE}
ggsave(here::here("assets/rstudio_conf_2020/ex_fig.png"), plot = ex_fig,
       height = 4, width = 4)
```


\begin{figure}[htb]
  \centering
  \includegraphics[width=0.6\textwidth]{ex_fig.png}
  \caption{Speed comparisons for each nesting approach.}
  \label{speed}
\end{figure}



# Discussion

List-columns are a useful approach to organizing 






# References
```{r create_r-references, echo = FALSE}
#r_refs(file = "r-references.bib")
```

\begingroup
\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}

<div id = "refs"></div>
\endgroup
